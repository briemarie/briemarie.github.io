<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <link type="text/CSS" rel="stylesheet" href="../cheatsheet.css">
  <title>JavaScript Prototypes</title>
</head>

<body>
  <h3>JavaScript Prototypes</h3>
  <p> JavaScript prototypes are objects that are similar to Class objects in Ruby. They are objects that come with a pack of methods, built in, for example .toString , .getPrototypeOf , and .hasOwnProperty are all methods that the Object prototype inherently has. Since all prototypes can be traced back up the tree to the Object prototype, all prototypes have the methods associated with Object, plus their own unique methods, such as .pop, .push, .shift, .unshift, .slice, and .sort that the Array prototype inherently has.  Furthermore, you can create your own prototypes, which are like the parent classes in Ruby that branch off into subclasses. All the subclasses inherit all the methods and properties of the parent class. In JS the parent class is the prototype and the subclasses are called instances of the prototype.</p>

  <h3>Key aspects to remember:</h3>
  <p>Prototypes are Capitalized to distinguish them from other objects.<br />
  JS comes with built in prototypes, but you can also create your own using, most commonly, the constructor function with the new syntax (example below).</p>

  <h3>All prototypes are objects, and they trace up the tree to the Object prototype, and the Object prototype is itself an object. Good ol Object Oriented Programming at work here.</h3>

  <img src= "../website-pics/prototype_tree.jpg"/>

  <h3>Most common methods for most common prototypes:</h3>

  <table>
    <table border="1" style="width:100%">
    <thead>
      <tr>
        <th>Array</th>
        <th>Function</th>
        <th>RegExp</th>
        <th>Date</th>
      </tr>
    </thead>
  <tr>
    <td>.pop, .push</td>
    <td>.call</td>
    <td>.exec</td>
    <td>.getDate, .getDay</td>
  </tr>
  <tr>
    <td>.shift, .unshift</td>
    <td>.bind</td>
    <td>.test</td>
    <td>.getHours, .getMinutes</td>
  </tr>
   <tr>
    <td>.slice, .join</td>
    <td>.apply</td>
    <td></td>
    <td>.getTimezoneOffset</td>
  </tr>
   <tr>
    <td>.sort, .splice</td>
    <td>.length</td>
    <td></td>
    <td>.toLocaleTimeString</td>
  </tr>
  <tr>
    <td>.concat, .reverse</td>
  </tr>
  <tr>
    <td>.length</td>
  </tr>
</table>

  <p>To make your own prototype, which by definition is "a first, typical or preliminary model of something, esp. a machine, from which other forms are developed or copied", you are creating a framework for actual instances of the objects you need. To do this using the constructor function, which is the most common and widely supported way, all you need are a few key words. Below is an example:<br />

    <code>function Vehicle(fuel, wheels, license) {<br />
      fuelType = fuel;<br />
      numOfWheels = wheels;<br />
      requiredLicense = license;<br />
    };</code>

    <br />
    <br />

  That is our prototype for Vehicle. Now lets create some instances of it.<br />

    <code>car = new Vehicle("gasoline", 4, "Class A Driver's License")<br />

    motorcycle = new Vehicle("gasoline", 2, "Class M Driver's License"</code>

    <br />
    <br />

  Now, if we want to see what we've done just type out:<br />

    <code>console.log(car)</code>

    <br />
    <br />

  And the results will be:<br />

    <code>fuelType: "gasoline", numOfWheels: 4 wheels, requiredLicense: "Class A Driver's License"</code>

    <br />
    <br />

  Now say we want to add another property to our prototype. The way to do this is by using the prototype property (We realize that is probably confusing, but here is the syntax to make it clear):<br />

    <code>Vehicle.prototype.maxSpeed = "some mph"</code>

    <br />
    <br />

  And now to add this to car and motorcycle instances we will simply add it like a normal object. The reason it does not automatically add to it is because now we have no perimeter set up in our function to account for maxSpeed, so it must be a manual input. This is probably one of the only drags about prototypes.<br />

    <code>car.maxSpeed = "140 mph"<br />
    motorcycle.maxSpeed = "150 mph"</code>

    <br />
    <br />

  Now, there is something tricky that happens when you create your own prototypes. Remember how it was noted that since all prototypes get traced back up to the Object prototype and therefore inherit those built in methods, such as .toString? Well, when you create your own prototype you are essecntially writing over those methods, so unless you specify that you want .toString to be a method, it is not going to transform your object into a string. It will however, return to you a string- the string will be "object Object". Basically what happens is that JS will read your object, see that it doesn't have a .toString method, but instead of returning an error, it will move up the prototype tree until it reaches the prototype that does have that method, which is the Object prototype. It then returns a string with the property of the Object prototype. Guess what the property of every prototype is- object! Because all prototypes are objects! Now, if one of the properties of your prototype is left empty, for example, if we didn't add 4 to car.numOfWheels, that would return undefined. But, the prototype objects themselves are never actually empty, they always have the property with the value of object.</p>

</body>

</html>